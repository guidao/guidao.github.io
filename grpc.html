<?xml version="1.0" encoding="utf-8"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN"
"http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" lang="en" xml:lang="en">
<head>
<!-- 2021-01-22 Fri 23:24 -->
<meta http-equiv="Content-Type" content="text/html;charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1" />
<title>GRPC golang版源码分析之客户端(一)</title>
<meta name="generator" content="Org mode" />
<link rel="stylesheet" type="text/css" href="./css/org-css.css"/>
<link rel="stylesheet" type="text/css" href="https://unpkg.com/gitalk/dist/gitalk.css"/> <script src="https://unpkg.com/gitalk/dist/gitalk.min.js"></script>
</head>
<body>
<div id="org-div-home-and-up">
 <a accesskey="h" href="index.html"> UP </a>
 |
 <a accesskey="H" href="index.html"> HOME </a>
</div><div id="content">
<h1 class="title">GRPC golang版源码分析之客户端(一)</h1>
<div id="table-of-contents">
<h2>Table of Contents</h2>
<div id="text-table-of-contents">
<ul>
<li><a href="#orgf6aea37">1. 前言</a></li>
<li><a href="#org5ecc9bd">2. 源码目录浏览</a></li>
<li><a href="#org9a831a8">3. 客户端</a></li>
<li><a href="#org837623a">4. 相关链接</a></li>
</ul>
</div>
</div>
<css>

<div id="outline-container-orgf6aea37" class="outline-2">
<h2 id="orgf6aea37"><span class="section-number-2">1</span> 前言</h2>
<div class="outline-text-2" id="text-1">
<p>
grpc是一个通用的rpc框架，用google实现，当然也有go语言的版本。在工作中主要用到这个库，所以看看源码加强自己对框架的了解。目前来说主要分析的都以go版本为主(并没有看其他语言版本).由于个人水平有限，代码中的有些思想也是个人揣测，难免有些错误，如果发现错误，还望帮忙指出。
</p>
</div>
</div>
<div id="outline-container-org5ecc9bd" class="outline-2">
<h2 id="org5ecc9bd"><span class="section-number-2">2</span> 源码目录浏览</h2>
<div class="outline-text-2" id="text-2">
<p>
grpc使用protobuf（google的序列化框架）作为通信协议，底层上使用http2作为其传输协议，grpc源码中自己实现了http2的服务端跟客户端，而并没有用net/http包。http2有很多特性能够高效的传输数据，具体特点可以看相关链接详细了解。
grpc目录如下:
<img src="./image/grpc_dir.png" alt="grpc_dir.png" />
看名字大概能看出这些目录中代码是哪些关系，documentation目录是存放一些文档，benchmark是压测，credentials是验证，examples是例子，grpclb是负载均衡，grpclog是日志,health是服务健康检查,metadata是元数据(用户客户端给服务端传送一些特殊数据，具体可以看相关链接),naming目录是提供名字服务需要实现的接口(相当于一个dns),stats是统计信息,transport 传输层实现(主要是http2的客户端与服务端时实现, 不会详细说这个目录),还有其他一些比较无关紧要的目录就不一一介绍了。
</p>
</div>
</div>

<div id="outline-container-org9a831a8" class="outline-2">
<h2 id="org9a831a8"><span class="section-number-2">3</span> 客户端</h2>
<div class="outline-text-2" id="text-3">
<p>
在example目录中有两个比较简单的例子，就先从这里入手吧，
</p>
<div class="org-src-container">
<pre class="src src-go"><span style="color: #89DDFF;">func</span> <span style="color: #82aaff;">main</span>() {
      <span style="color: #676E95;">// </span><span style="color: #676E95;">Set up a connection to the server.</span>
      <span style="color: #676E95;">//</span><span style="color: #676E95;">&#24314;&#31435;&#19968;&#20010;&#38142;&#25509;</span>
      <span style="color: #ffcb6b;">conn</span>, <span style="color: #ffcb6b;">err</span> := grpc.<span style="color: #82aaff;">Dial</span>(address, grpc.<span style="color: #82aaff;">WithInsecure</span>())
      <span style="color: #89DDFF;">if</span> err != <span style="color: #f78c6c;">nil</span> {
          log.<span style="color: #82aaff;">Fatalf</span>(<span style="color: #c3e88d;">"did not connect: %v"</span>, err)
      }
      <span style="color: #89DDFF;">defer</span> conn.<span style="color: #82aaff;">Close</span>()
      <span style="color: #ffcb6b;">c</span> := pb.<span style="color: #82aaff;">NewGreeterClient</span>(conn)

      <span style="color: #676E95;">// </span><span style="color: #676E95;">Contact the server and print out its response.</span>
      <span style="color: #ffcb6b;">name</span> := defaultName
      <span style="color: #89DDFF;">if</span> <span style="color: #82aaff;">len</span>(os.Args) &gt; 1 {
          name = os.Args[1]
      }
      <span style="color: #676E95;">//</span><span style="color: #676E95;">&#35843;&#29992;&#20989;&#25968;</span>
      <span style="color: #ffcb6b;">r</span>, <span style="color: #ffcb6b;">err</span> := c.<span style="color: #82aaff;">SayHello</span>(context.<span style="color: #82aaff;">Background</span>(), &amp;<span style="color: #c792ea;">pb.HelloRequest</span>{<span style="color: #f78c6c;">Name</span>: name})
      <span style="color: #89DDFF;">if</span> err != <span style="color: #f78c6c;">nil</span> {
          log.<span style="color: #82aaff;">Fatalf</span>(<span style="color: #c3e88d;">"could not greet: %v"</span>, err)
      }
      log.<span style="color: #82aaff;">Printf</span>(<span style="color: #c3e88d;">"Greeting: %s"</span>, r.Message)
}
</pre>
</div>
<p>
grcp.WithInsecure参数是在链接https服务端时不用检查服务端的证书(要是你相信服务端就不用检查).Dial函数对服务端建立一个连接，
grpc.Dial函数:
</p>
<div class="org-src-container">
<pre class="src src-go"><span style="color: #89DDFF;">func</span> <span style="color: #82aaff;">DialContext</span>(<span style="color: #ffcb6b;">ctx</span> <span style="color: #c792ea;">context.Context</span>, <span style="color: #ffcb6b;">target</span> <span style="color: #c792ea;">string</span>, <span style="color: #ffcb6b;">opts</span> ...<span style="color: #c792ea;">DialOption</span>) (<span style="color: #ffcb6b;">conn</span> *<span style="color: #c792ea;">ClientConn</span>, <span style="color: #ffcb6b;">err</span> <span style="color: #c792ea;">error</span>) {
      <span style="color: #ffcb6b;">cc</span> := &amp;<span style="color: #c792ea;">ClientConn</span>{
          <span style="color: #f78c6c;">target</span>: target,
          <span style="color: #f78c6c;">conns</span>:  <span style="color: #82aaff;">make</span>(<span style="color: #89DDFF;">map</span>[<span style="color: #c792ea;">Address</span>]*<span style="color: #c792ea;">addrConn</span>),
      }
      cc.ctx, cc.cancel = context.<span style="color: #82aaff;">WithCancel</span>(context.<span style="color: #82aaff;">Background</span>())
      <span style="color: #89DDFF;">defer</span> <span style="color: #89DDFF;">func</span>() {
          <span style="color: #89DDFF;">select</span> {
          <span style="color: #89DDFF;">case</span> &lt;-ctx.<span style="color: #82aaff;">Done</span>():
              conn, err = <span style="color: #f78c6c;">nil</span>, ctx.<span style="color: #82aaff;">Err</span>()
          <span style="color: #89DDFF;">default</span>:
          }

          <span style="color: #89DDFF;">if</span> err != <span style="color: #f78c6c;">nil</span> {
              cc.<span style="color: #82aaff;">Close</span>()
          }
      }()

      <span style="color: #676E95;">//</span><span style="color: #676E95;">&#35774;&#32622;grpc&#30340;&#21508;&#31181;&#36873;&#39033;</span>
      <span style="color: #89DDFF;">for</span> <span style="color: #ffcb6b;">_</span>, <span style="color: #ffcb6b;">opt</span> := <span style="color: #89DDFF;">range</span> opts {
          <span style="color: #82aaff;">opt</span>(&amp;cc.dopts)
      }

      <span style="color: #676E95;">// </span><span style="color: #676E95;">Set defaults.</span>
      <span style="color: #89DDFF;">if</span> cc.dopts.codec == <span style="color: #f78c6c;">nil</span> {
          <span style="color: #676E95;">//</span><span style="color: #676E95;">&#40664;&#35748;&#29992;protobuf&#32534;&#35299;&#30721;</span>
          cc.dopts.codec = <span style="color: #c792ea;">protoCodec</span>{}
      }
      <span style="color: #89DDFF;">if</span> cc.dopts.bs == <span style="color: #f78c6c;">nil</span> {
          cc.dopts.bs = DefaultBackoffConfig
      }
      <span style="color: #ffcb6b;">creds</span> := cc.dopts.copts.TransportCredentials
      <span style="color: #676E95;">//</span><span style="color: #676E95;">&#39564;&#35777;&#20449;&#24687;</span>
      <span style="color: #89DDFF;">if</span> creds != <span style="color: #f78c6c;">nil</span> &amp;&amp; creds.<span style="color: #82aaff;">Info</span>().ServerName != <span style="color: #c3e88d;">""</span> {
          cc.authority = creds.<span style="color: #82aaff;">Info</span>().ServerName
      } <span style="color: #89DDFF;">else</span> {
          <span style="color: #ffcb6b;">colonPos</span> := strings.<span style="color: #82aaff;">LastIndex</span>(target, <span style="color: #c3e88d;">":"</span>)
          <span style="color: #89DDFF;">if</span> colonPos == -1 {
              colonPos = <span style="color: #82aaff;">len</span>(target)
          }
          cc.authority = target[:colonPos]
      }
      <span style="color: #89DDFF;">var</span> <span style="color: #ffcb6b;">ok</span> <span style="color: #c792ea;">bool</span>
      <span style="color: #ffcb6b;">waitC</span> := <span style="color: #82aaff;">make</span>(<span style="color: #89DDFF;">chan</span> <span style="color: #c792ea;">error</span>, 1)
      <span style="color: #676E95;">//</span><span style="color: #676E95;">&#21551;&#21160;&#19968;&#20010;goroutine&#21551;&#21160;&#21517;&#23383;&#26381;&#21153;&#22120;(&#31867;&#20284;dns)</span>
      <span style="color: #89DDFF;">go</span> <span style="color: #89DDFF;">func</span>() {
          <span style="color: #89DDFF;">var</span> <span style="color: #ffcb6b;">addrs</span> []<span style="color: #c792ea;">Address</span>
          <span style="color: #89DDFF;">if</span> cc.dopts.balancer == <span style="color: #f78c6c;">nil</span> {
              <span style="color: #676E95;">// </span><span style="color: #676E95;">Connect to target directly if balancer is nil.</span>
              <span style="color: #676E95;">// </span><span style="color: #676E95;">&#22914;&#26524;&#27809;&#35774;&#32622;&#36127;&#36733;&#22343;&#34913;&#22120;&#65292;&#21017;&#30452;&#25509;&#36830;&#25509;</span>
              addrs = <span style="color: #82aaff;">append</span>(addrs, <span style="color: #c792ea;">Address</span>{<span style="color: #f78c6c;">Addr</span>: target})
          } <span style="color: #89DDFF;">else</span> {
              <span style="color: #89DDFF;">var</span> <span style="color: #ffcb6b;">credsClone</span> <span style="color: #c792ea;">credentials.TransportCredentials</span>
              <span style="color: #89DDFF;">if</span> creds != <span style="color: #f78c6c;">nil</span> {
                  credsClone = creds.<span style="color: #82aaff;">Clone</span>()
              }
              <span style="color: #ffcb6b;">config</span> := <span style="color: #c792ea;">BalancerConfig</span>{
                  <span style="color: #f78c6c;">DialCreds</span>: credsClone,
              }
              <span style="color: #676E95;">//</span><span style="color: #676E95;">&#21551;&#21160;&#36127;&#36733;&#22343;&#34913;&#26381;&#21153;</span>
              <span style="color: #89DDFF;">if</span> <span style="color: #ffcb6b;">err</span> := cc.dopts.balancer.<span style="color: #82aaff;">Start</span>(target, config); err != <span style="color: #f78c6c;">nil</span> {
                  waitC &lt;- err
                  <span style="color: #89DDFF;">return</span>
              }
              <span style="color: #ffcb6b;">ch</span> := cc.dopts.balancer.<span style="color: #82aaff;">Notify</span>()
              <span style="color: #89DDFF;">if</span> ch == <span style="color: #f78c6c;">nil</span> {
                  <span style="color: #676E95;">// </span><span style="color: #676E95;">There is no name resolver installed.</span>
                  addrs = <span style="color: #82aaff;">append</span>(addrs, <span style="color: #c792ea;">Address</span>{<span style="color: #f78c6c;">Addr</span>: target})
              } <span style="color: #89DDFF;">else</span> {
                  addrs, ok = &lt;-ch
                  <span style="color: #89DDFF;">if</span> <span style="color: #89DDFF; font-weight: bold;">!</span>ok || <span style="color: #82aaff;">len</span>(addrs) == 0 {
                      waitC &lt;- errNoAddr
                      <span style="color: #89DDFF;">return</span>
                  }
              }
          }
          <span style="color: #89DDFF;">for</span> <span style="color: #ffcb6b;">_</span>, <span style="color: #ffcb6b;">a</span> := <span style="color: #89DDFF;">range</span> addrs {
              <span style="color: #676E95;">//</span><span style="color: #676E95;">&#32473;&#27599;&#20010;&#22320;&#22336;&#19968;&#20010;conn&#65292;&#36830;&#25509;&#27744;</span>
              <span style="color: #89DDFF;">if</span> <span style="color: #ffcb6b;">err</span> := cc.<span style="color: #82aaff;">resetAddrConn</span>(a, <span style="color: #f78c6c;">false</span>, <span style="color: #f78c6c;">nil</span>); err != <span style="color: #f78c6c;">nil</span> {
                  waitC &lt;- err
                  <span style="color: #89DDFF;">return</span>
              }
          }
          <span style="color: #82aaff;">close</span>(waitC)
      }()
      <span style="color: #89DDFF;">var</span> <span style="color: #ffcb6b;">timeoutCh</span> &lt;-<span style="color: #89DDFF;">chan</span> <span style="color: #ffcb6b;">time</span>.Time
      <span style="color: #89DDFF;">if</span> cc.dopts.timeout &gt; 0 {
          timeoutCh = time.<span style="color: #82aaff;">After</span>(cc.dopts.timeout)
      }
      <span style="color: #89DDFF;">select</span> {
      <span style="color: #89DDFF;">case</span> &lt;-ctx.<span style="color: #82aaff;">Done</span>():
          <span style="color: #89DDFF;">return</span> <span style="color: #f78c6c;">nil</span>, ctx.<span style="color: #82aaff;">Err</span>()
      <span style="color: #89DDFF;">case</span> <span style="color: #ffcb6b;">err</span> := &lt;-waitC:
          <span style="color: #89DDFF;">if</span> err != <span style="color: #f78c6c;">nil</span> {
              <span style="color: #89DDFF;">return</span> <span style="color: #f78c6c;">nil</span>, err
          }
      <span style="color: #89DDFF;">case</span> &lt;-timeoutCh:
          <span style="color: #89DDFF;">return</span> <span style="color: #f78c6c;">nil</span>, ErrClientConnTimeout
      }
      <span style="color: #676E95;">// </span><span style="color: #676E95;">If balancer is nil or balancer.Notify() is nil, ok will be false here.</span>
      <span style="color: #676E95;">// </span><span style="color: #676E95;">The lbWatcher goroutine will not be created.</span>
      <span style="color: #89DDFF;">if</span> ok {
          <span style="color: #89DDFF;">go</span> cc.<span style="color: #82aaff;">lbWatcher</span>()
      }
      <span style="color: #89DDFF;">return</span> cc, <span style="color: #f78c6c;">nil</span>
}
</pre>
</div>
<p>
通过dial这个函数，grpc已经建立了到服务端的连接，启动了自定义负载平衡（如果有的话）. pb.NewGreeterClient这行代码是通过protoc工具自动生成的，它包一个grpc连接包裹在一个struct内方便调用生成的客户端grpc调用代码。接下来grpc客户端调用SayHello向服务器发送rpc请求。
</p>
<div class="org-src-container">
<pre class="src src-go"><span style="color: #89DDFF;">func</span> (<span style="color: #ffcb6b;">c</span> *<span style="color: #c792ea;">greeterClient</span>) <span style="color: #82aaff;">SayHello</span>(<span style="color: #ffcb6b;">ctx</span> <span style="color: #c792ea;">context.Context</span>, <span style="color: #ffcb6b;">in</span> *<span style="color: #c792ea;">HelloRequest</span>, <span style="color: #ffcb6b;">opts</span> ...<span style="color: #c792ea;">grpc.CallOption</span>) (*<span style="color: #c792ea;">HelloReply</span>, <span style="color: #c792ea;">error</span>) {
      <span style="color: #ffcb6b;">out</span> := <span style="color: #82aaff;">new</span>(<span style="color: #c792ea;">HelloReply</span>)
      <span style="color: #676E95;">//</span><span style="color: #676E95;">&#35843;&#29992;&#23454;&#38469;&#30340;&#21457;&#36865;&#35831;&#27714;&#20989;&#25968;</span>
      <span style="color: #ffcb6b;">err</span> := grpc.<span style="color: #82aaff;">Invoke</span>(ctx, <span style="color: #c3e88d;">"/helloworld.Greeter/SayHello"</span>, in, out, c.cc, opts...)
      <span style="color: #89DDFF;">if</span> err != <span style="color: #f78c6c;">nil</span> {
          <span style="color: #89DDFF;">return</span> <span style="color: #f78c6c;">nil</span>, err
      }
      <span style="color: #89DDFF;">return</span> out, <span style="color: #f78c6c;">nil</span>
}

<span style="color: #676E95;">//</span><span style="color: #676E95;">&#26368;&#21518;&#20027;&#35201;&#26159;invoke&#20989;&#25968;</span>
<span style="color: #89DDFF;">func</span> <span style="color: #82aaff;">invoke</span>(<span style="color: #ffcb6b;">ctx</span> <span style="color: #c792ea;">context.Context</span>, <span style="color: #ffcb6b;">method</span> <span style="color: #c792ea;">string</span>, <span style="color: #ffcb6b;">args</span>, <span style="color: #ffcb6b;">reply</span> <span style="color: #89DDFF;">interface</span>{}, <span style="color: #ffcb6b;">cc</span> *<span style="color: #c792ea;">ClientConn</span>, <span style="color: #ffcb6b;">opts</span> ...<span style="color: #c792ea;">CallOption</span>) (<span style="color: #ffcb6b;">e</span> <span style="color: #c792ea;">error</span>) {
      <span style="color: #ffcb6b;">c</span> := defaultCallInfo
      <span style="color: #89DDFF;">for</span> <span style="color: #ffcb6b;">_</span>, <span style="color: #ffcb6b;">o</span> := <span style="color: #89DDFF;">range</span> opts {
          <span style="color: #676E95;">//</span><span style="color: #676E95;">&#35843;&#29992;&#20043;&#21069;&#30340;hook</span>
          <span style="color: #89DDFF;">if</span> <span style="color: #ffcb6b;">err</span> := o.<span style="color: #82aaff;">before</span>(&amp;c); err != <span style="color: #f78c6c;">nil</span> {
              <span style="color: #89DDFF;">return</span> <span style="color: #82aaff;">toRPCErr</span>(err)
          }
      }
      <span style="color: #89DDFF;">defer</span> <span style="color: #89DDFF;">func</span>() {
          <span style="color: #89DDFF;">for</span> <span style="color: #ffcb6b;">_</span>, <span style="color: #ffcb6b;">o</span> := <span style="color: #89DDFF;">range</span> opts {
              <span style="color: #676E95;">//</span><span style="color: #676E95;">&#25191;&#34892;&#23436;&#21518;&#30340;hook</span>
              o.<span style="color: #82aaff;">after</span>(&amp;c)
          }
      }()
      <span style="color: #676E95;">//</span><span style="color: #676E95;">trace&#30456;&#20851;&#20195;&#30721;</span>
      <span style="color: #89DDFF;">if</span> EnableTracing {
          c.traceInfo.tr = trace.<span style="color: #82aaff;">New</span>(<span style="color: #c3e88d;">"grpc.Sent."</span>+<span style="color: #82aaff;">methodFamily</span>(method), method)
          <span style="color: #89DDFF;">defer</span> c.traceInfo.tr.<span style="color: #82aaff;">Finish</span>()
          c.traceInfo.firstLine.client = <span style="color: #f78c6c;">true</span>
          <span style="color: #89DDFF;">if</span> <span style="color: #ffcb6b;">deadline</span>, <span style="color: #ffcb6b;">ok</span> := ctx.<span style="color: #82aaff;">Deadline</span>(); ok {
              c.traceInfo.firstLine.deadline = deadline.<span style="color: #82aaff;">Sub</span>(time.<span style="color: #82aaff;">Now</span>())
          }
          c.traceInfo.tr.<span style="color: #82aaff;">LazyLog</span>(&amp;c.traceInfo.firstLine, <span style="color: #f78c6c;">false</span>)
          <span style="color: #676E95;">// </span><span style="color: #cc9393;">TODO</span><span style="color: #676E95;">(dsymonds): Arrange for c.traceInfo.firstLine.remoteAddr to be set.</span>
          <span style="color: #89DDFF;">defer</span> <span style="color: #89DDFF;">func</span>() {
              <span style="color: #89DDFF;">if</span> e != <span style="color: #f78c6c;">nil</span> {
                  c.traceInfo.tr.<span style="color: #82aaff;">LazyLog</span>(&amp;<span style="color: #c792ea;">fmtStringer</span>{<span style="color: #c3e88d;">"%v"</span>, []<span style="color: #89DDFF;">interface</span>{}{e}}, <span style="color: #f78c6c;">true</span>)
                  c.traceInfo.tr.<span style="color: #82aaff;">SetError</span>()
              }
          }()
      }
      <span style="color: #676E95;">//</span><span style="color: #676E95;">&#32479;&#35745;&#30456;&#20851;&#20195;&#30721;</span>
      <span style="color: #89DDFF;">if</span> stats.<span style="color: #82aaff;">On</span>() {
          ctx = stats.<span style="color: #82aaff;">TagRPC</span>(ctx, &amp;<span style="color: #c792ea;">stats.RPCTagInfo</span>{<span style="color: #f78c6c;">FullMethodName</span>: method})
          <span style="color: #ffcb6b;">begin</span> := &amp;<span style="color: #c792ea;">stats.Begin</span>{
              <span style="color: #f78c6c;">Client</span>:    <span style="color: #f78c6c;">true</span>,
              <span style="color: #f78c6c;">BeginTime</span>: time.<span style="color: #82aaff;">Now</span>(),
              <span style="color: #f78c6c;">FailFast</span>:  c.failFast,
          }
          stats.<span style="color: #82aaff;">HandleRPC</span>(ctx, begin)
      }
      <span style="color: #89DDFF;">defer</span> <span style="color: #89DDFF;">func</span>() {
          <span style="color: #676E95;">//</span><span style="color: #676E95;">&#32467;&#26463;&#21518;&#30340;&#32479;&#35745;&#30456;&#20851;&#20195;&#30721;</span>
          <span style="color: #89DDFF;">if</span> stats.<span style="color: #82aaff;">On</span>() {
              <span style="color: #ffcb6b;">end</span> := &amp;<span style="color: #c792ea;">stats.End</span>{
                  <span style="color: #f78c6c;">Client</span>:  <span style="color: #f78c6c;">true</span>,
                  <span style="color: #f78c6c;">EndTime</span>: time.<span style="color: #82aaff;">Now</span>(),
                  <span style="color: #f78c6c;">Error</span>:   e,
              }
              stats.<span style="color: #82aaff;">HandleRPC</span>(ctx, end)
          }
      }()
      <span style="color: #ffcb6b;">topts</span> := &amp;<span style="color: #c792ea;">transport.Options</span>{
          <span style="color: #f78c6c;">Last</span>:  <span style="color: #f78c6c;">true</span>,
          <span style="color: #f78c6c;">Delay</span>: <span style="color: #f78c6c;">false</span>,
      }
      <span style="color: #89DDFF;">for</span> {
          <span style="color: #89DDFF;">var</span> (
              <span style="color: #ffcb6b;">err</span>    <span style="color: #c792ea;">error</span>
              <span style="color: #ffcb6b;">t</span>      <span style="color: #c792ea;">transport.ClientTransport</span>
              <span style="color: #ffcb6b;">stream</span> *<span style="color: #c792ea;">transport.Stream</span>
              <span style="color: #676E95;">// </span><span style="color: #676E95;">Record the put handler from Balancer.Get(...). It is called once the</span>
              <span style="color: #676E95;">// </span><span style="color: #676E95;">RPC has completed or failed.</span>
              <span style="color: #ffcb6b;">put</span> <span style="color: #89DDFF;">func</span>()
          )
          <span style="color: #676E95;">// </span><span style="color: #cc9393;">TODO</span><span style="color: #676E95;">(zhaoq): Need a formal spec of fail-fast.</span>
          <span style="color: #676E95;">//</span><span style="color: #676E95;">&#20256;&#36755;&#23618;&#30340;&#37197;&#32622;</span>
          <span style="color: #ffcb6b;">callHdr</span> := &amp;<span style="color: #c792ea;">transport.CallHdr</span>{
              <span style="color: #f78c6c;">Host</span>:   cc.authority,
              <span style="color: #f78c6c;">Method</span>: method,
          }
          <span style="color: #89DDFF;">if</span> cc.dopts.cp != <span style="color: #f78c6c;">nil</span> {
              callHdr.SendCompress = cc.dopts.cp.<span style="color: #82aaff;">Type</span>()
          }
          <span style="color: #ffcb6b;">gopts</span> := <span style="color: #c792ea;">BalancerGetOptions</span>{
              <span style="color: #f78c6c;">BlockingWait</span>: <span style="color: #89DDFF; font-weight: bold;">!</span>c.failFast,
          }
          <span style="color: #676E95;">//</span><span style="color: #676E95;">&#24471;&#21040;&#20256;&#36755;&#25104;&#36830;&#25509;&#65292;&#22312;http2&#20013;&#19968;&#20010;&#20256;&#36755;&#21333;&#20301;&#26159;&#19968;&#20010;&#27969;&#12290;</span>
          t, put, err = cc.<span style="color: #82aaff;">getTransport</span>(ctx, gopts)
          <span style="color: #89DDFF;">if</span> err != <span style="color: #f78c6c;">nil</span> {
              <span style="color: #676E95;">// </span><span style="color: #cc9393;">TODO</span><span style="color: #676E95;">(zhaoq): Probably revisit the error handling.</span>
              <span style="color: #89DDFF;">if</span> <span style="color: #ffcb6b;">_</span>, <span style="color: #ffcb6b;">ok</span> := err.(*<span style="color: #c792ea;">rpcError</span>); ok {
                  <span style="color: #89DDFF;">return</span> err
              }
              <span style="color: #89DDFF;">if</span> err == errConnClosing || err == errConnUnavailable {
                  <span style="color: #89DDFF;">if</span> c.failFast {
                      <span style="color: #89DDFF;">return</span> <span style="color: #82aaff;">Errorf</span>(codes.Unavailable, <span style="color: #c3e88d;">"%v"</span>, err)
                  }
                  <span style="color: #89DDFF;">continue</span>
              }
              <span style="color: #676E95;">// </span><span style="color: #676E95;">All the other errors are treated as Internal errors.</span>
              <span style="color: #89DDFF;">return</span> <span style="color: #82aaff;">Errorf</span>(codes.Internal, <span style="color: #c3e88d;">"%v"</span>, err)
          }
          <span style="color: #89DDFF;">if</span> c.traceInfo.tr != <span style="color: #f78c6c;">nil</span> {
              c.traceInfo.tr.<span style="color: #82aaff;">LazyLog</span>(&amp;<span style="color: #c792ea;">payload</span>{<span style="color: #f78c6c;">sent</span>: <span style="color: #f78c6c;">true</span>, <span style="color: #f78c6c;">msg</span>: args}, <span style="color: #f78c6c;">true</span>)
          }
          <span style="color: #676E95;">// </span><span style="color: #676E95;">&#21457;&#36865;&#35831;&#27714;</span>
          stream, err = <span style="color: #82aaff;">sendRequest</span>(ctx, cc.dopts.codec, cc.dopts.cp, callHdr, t, args, topts)
          <span style="color: #89DDFF;">if</span> err != <span style="color: #f78c6c;">nil</span> {
              <span style="color: #89DDFF;">if</span> put != <span style="color: #f78c6c;">nil</span> {
                  <span style="color: #82aaff;">put</span>()
                  put = <span style="color: #f78c6c;">nil</span>
              }
              <span style="color: #676E95;">// </span><span style="color: #676E95;">Retry a non-failfast RPC when</span>
              <span style="color: #676E95;">// </span><span style="color: #676E95;">i) there is a connection error; or</span>
              <span style="color: #676E95;">// </span><span style="color: #676E95;">ii) the server started to drain before this RPC was initiated.</span>
              <span style="color: #676E95;">// </span><span style="color: #676E95;">&#22312;&#36825;&#20004;&#31181;&#24773;&#20917;&#19979;&#37325;&#35797;&#65292;1 &#38142;&#25509;&#38169;&#35823; 2 &#22312;rpc&#21021;&#22987;&#21270;&#20043;&#21069;&#26381;&#21153;&#31471;&#24050;&#32463;&#24320;&#22987;&#26381;&#21153;</span>
              <span style="color: #89DDFF;">if</span> <span style="color: #ffcb6b;">_</span>, <span style="color: #ffcb6b;">ok</span> := err.(<span style="color: #c792ea;">transport.ConnectionError</span>); ok || err == transport.ErrStreamDrain {
                  <span style="color: #89DDFF;">if</span> c.failFast {
                      <span style="color: #89DDFF;">return</span> <span style="color: #82aaff;">toRPCErr</span>(err)
                  }
                  <span style="color: #89DDFF;">continue</span>
              }
              <span style="color: #89DDFF;">return</span> <span style="color: #82aaff;">toRPCErr</span>(err)
          }
          <span style="color: #676E95;">//</span><span style="color: #676E95;">&#25910;&#28040;&#24687;</span>
          err = <span style="color: #82aaff;">recvResponse</span>(ctx, cc.dopts, t, &amp;c, stream, reply)
          <span style="color: #89DDFF;">if</span> err != <span style="color: #f78c6c;">nil</span> {
              <span style="color: #89DDFF;">if</span> put != <span style="color: #f78c6c;">nil</span> {
                  <span style="color: #82aaff;">put</span>()
                  put = <span style="color: #f78c6c;">nil</span>
              }
              <span style="color: #89DDFF;">if</span> <span style="color: #ffcb6b;">_</span>, <span style="color: #ffcb6b;">ok</span> := err.(<span style="color: #c792ea;">transport.ConnectionError</span>); ok || err == transport.ErrStreamDrain {
                  <span style="color: #89DDFF;">if</span> c.failFast {
                      <span style="color: #89DDFF;">return</span> <span style="color: #82aaff;">toRPCErr</span>(err)
                  }
                  <span style="color: #89DDFF;">continue</span>
              }
              <span style="color: #89DDFF;">return</span> <span style="color: #82aaff;">toRPCErr</span>(err)
          }
          <span style="color: #89DDFF;">if</span> c.traceInfo.tr != <span style="color: #f78c6c;">nil</span> {
              c.traceInfo.tr.<span style="color: #82aaff;">LazyLog</span>(&amp;<span style="color: #c792ea;">payload</span>{<span style="color: #f78c6c;">sent</span>: <span style="color: #f78c6c;">false</span>, <span style="color: #f78c6c;">msg</span>: reply}, <span style="color: #f78c6c;">true</span>)
          }
          <span style="color: #676E95;">//</span><span style="color: #676E95;">&#20851;&#38381;&#19968;&#20010;http2&#27969;</span>
          t.<span style="color: #82aaff;">CloseStream</span>(stream, <span style="color: #f78c6c;">nil</span>)
          <span style="color: #89DDFF;">if</span> put != <span style="color: #f78c6c;">nil</span> {
              <span style="color: #82aaff;">put</span>()
              put = <span style="color: #f78c6c;">nil</span>
          }
          <span style="color: #676E95;">//</span><span style="color: #676E95;">Errorf&#20250;&#21028;&#26029;&#36820;&#22238;&#21313;&#20998;ok</span>
          <span style="color: #89DDFF;">return</span> <span style="color: #82aaff;">Errorf</span>(stream.<span style="color: #82aaff;">StatusCode</span>(), <span style="color: #c3e88d;">"%s"</span>, stream.<span style="color: #82aaff;">StatusDesc</span>())
      }
}
</pre>
</div>
<p>
在这个函数最主要是两个函数，一个是sendRequest,一个是recvResponse,首先看看sendRequest函数：
</p>
<div class="org-src-container">
<pre class="src src-go"><span style="color: #89DDFF;">func</span> <span style="color: #82aaff;">sendRequest</span>(<span style="color: #ffcb6b;">ctx</span> <span style="color: #c792ea;">context.Context</span>, <span style="color: #ffcb6b;">codec</span> <span style="color: #c792ea;">Codec</span>, <span style="color: #ffcb6b;">compressor</span> <span style="color: #c792ea;">Compressor</span>, <span style="color: #ffcb6b;">callHdr</span> *<span style="color: #c792ea;">transport.CallHdr</span>, <span style="color: #ffcb6b;">t</span> <span style="color: #c792ea;">transport.ClientTransport</span>, <span style="color: #ffcb6b;">args</span> <span style="color: #89DDFF;">interface</span>{}, <span style="color: #ffcb6b;">opts</span> *<span style="color: #c792ea;">transport.Options</span>) (<span style="color: #ffcb6b;">_</span> *<span style="color: #c792ea;">transport.Stream</span>, <span style="color: #ffcb6b;">err</span> <span style="color: #c792ea;">error</span>) {
      <span style="color: #676E95;">// </span><span style="color: #676E95;">&#21019;&#24314;&#19968;&#20010;http2&#27969;</span>
      <span style="color: #ffcb6b;">stream</span>, <span style="color: #ffcb6b;">err</span> := t.<span style="color: #82aaff;">NewStream</span>(ctx, callHdr)
      <span style="color: #89DDFF;">if</span> err != <span style="color: #f78c6c;">nil</span> {
          <span style="color: #89DDFF;">return</span> <span style="color: #f78c6c;">nil</span>, err
      }
      <span style="color: #89DDFF;">defer</span> <span style="color: #89DDFF;">func</span>() {
          <span style="color: #89DDFF;">if</span> err != <span style="color: #f78c6c;">nil</span> {
              <span style="color: #676E95;">// </span><span style="color: #676E95;">If err is connection error, t will be closed, no need to close stream here.</span>
              <span style="color: #89DDFF;">if</span> <span style="color: #ffcb6b;">_</span>, <span style="color: #ffcb6b;">ok</span> := err.(<span style="color: #c792ea;">transport.ConnectionError</span>); <span style="color: #89DDFF; font-weight: bold;">!</span>ok {
                  t.<span style="color: #82aaff;">CloseStream</span>(stream, err)
              }
          }
      }()
      <span style="color: #89DDFF;">var</span> (
          <span style="color: #ffcb6b;">cbuf</span>       *<span style="color: #c792ea;">bytes.Buffer</span>
          <span style="color: #ffcb6b;">outPayload</span> *<span style="color: #c792ea;">stats.OutPayload</span>
      )
      <span style="color: #676E95;">//</span><span style="color: #676E95;">&#21387;&#32553;&#19981;&#20026;&#31354;</span>
      <span style="color: #89DDFF;">if</span> compressor != <span style="color: #f78c6c;">nil</span> {
          cbuf = <span style="color: #82aaff;">new</span>(<span style="color: #c792ea;">bytes.Buffer</span>)
      }
      <span style="color: #676E95;">//</span><span style="color: #676E95;">&#32479;&#35745;</span>
      <span style="color: #89DDFF;">if</span> stats.<span style="color: #82aaff;">On</span>() {
          outPayload = &amp;<span style="color: #c792ea;">stats.OutPayload</span>{
              <span style="color: #f78c6c;">Client</span>: <span style="color: #f78c6c;">true</span>,
          }
      }
      <span style="color: #676E95;">//</span><span style="color: #676E95;">&#32534;&#30721;&#24182;&#21387;&#32553;&#25968;&#25454;</span>
      <span style="color: #ffcb6b;">outBuf</span>, <span style="color: #ffcb6b;">err</span> := <span style="color: #82aaff;">encode</span>(codec, args, compressor, cbuf, outPayload)
      <span style="color: #89DDFF;">if</span> err != <span style="color: #f78c6c;">nil</span> {
          <span style="color: #89DDFF;">return</span> <span style="color: #f78c6c;">nil</span>, <span style="color: #82aaff;">Errorf</span>(codes.Internal, <span style="color: #c3e88d;">"grpc: %v"</span>, err)
      }
      <span style="color: #676E95;">//</span><span style="color: #676E95;">&#20889;&#20837;&#27969;</span>
      err = t.<span style="color: #82aaff;">Write</span>(stream, outBuf, opts)
      <span style="color: #89DDFF;">if</span> err == <span style="color: #f78c6c;">nil</span> &amp;&amp; outPayload != <span style="color: #f78c6c;">nil</span> {
          outPayload.SentTime = time.<span style="color: #82aaff;">Now</span>()
          stats.<span style="color: #82aaff;">HandleRPC</span>(ctx, outPayload)
      }
      <span style="color: #676E95;">// </span><span style="color: #676E95;">t.NewStream(...) could lead to an early rejection of the RPC (e.g., the service/method</span>
      <span style="color: #676E95;">// </span><span style="color: #676E95;">does not exist.) so that t.Write could get io.EOF from wait(...). Leave the following</span>
      <span style="color: #676E95;">// </span><span style="color: #676E95;">recvResponse to get the final status.</span>
      <span style="color: #89DDFF;">if</span> err != <span style="color: #f78c6c;">nil</span> &amp;&amp; err != io.EOF {
          <span style="color: #89DDFF;">return</span> <span style="color: #f78c6c;">nil</span>, err
      }
      <span style="color: #676E95;">// </span><span style="color: #676E95;">Sent successfully.</span>
      <span style="color: #89DDFF;">return</span> stream, <span style="color: #f78c6c;">nil</span>
}
</pre>
</div>
<p>
可以看到这个函数相当简单，做了两件事情，编码压缩数据并发送.再来看看recvResponse函数：
</p>
<div class="org-src-container">
<pre class="src src-go"><span style="color: #89DDFF;">func</span> <span style="color: #82aaff;">recvResponse</span>(<span style="color: #ffcb6b;">ctx</span> <span style="color: #c792ea;">context.Context</span>, <span style="color: #ffcb6b;">dopts</span> <span style="color: #c792ea;">dialOptions</span>, <span style="color: #ffcb6b;">t</span> <span style="color: #c792ea;">transport.ClientTransport</span>, <span style="color: #ffcb6b;">c</span> *<span style="color: #c792ea;">callInfo</span>, <span style="color: #ffcb6b;">stream</span> *<span style="color: #c792ea;">transport.Stream</span>, <span style="color: #ffcb6b;">reply</span> <span style="color: #89DDFF;">interface</span>{}) (<span style="color: #ffcb6b;">err</span> <span style="color: #c792ea;">error</span>) {
      <span style="color: #676E95;">// </span><span style="color: #676E95;">Try to acquire header metadata from the server if there is any.</span>
      <span style="color: #89DDFF;">defer</span> <span style="color: #89DDFF;">func</span>() {
          <span style="color: #89DDFF;">if</span> err != <span style="color: #f78c6c;">nil</span> {
              <span style="color: #89DDFF;">if</span> <span style="color: #ffcb6b;">_</span>, <span style="color: #ffcb6b;">ok</span> := err.(<span style="color: #c792ea;">transport.ConnectionError</span>); <span style="color: #89DDFF; font-weight: bold;">!</span>ok {
                  t.<span style="color: #82aaff;">CloseStream</span>(stream, err)
              }
          }
      }()
      c.headerMD, err = stream.<span style="color: #82aaff;">Header</span>()
      <span style="color: #89DDFF;">if</span> err != <span style="color: #f78c6c;">nil</span> {
          <span style="color: #89DDFF;">return</span>
      }
      <span style="color: #ffcb6b;">p</span> := &amp;<span style="color: #c792ea;">parser</span>{<span style="color: #f78c6c;">r</span>: stream}
      <span style="color: #89DDFF;">var</span> <span style="color: #ffcb6b;">inPayload</span> *<span style="color: #c792ea;">stats.InPayload</span>
      <span style="color: #89DDFF;">if</span> stats.<span style="color: #82aaff;">On</span>() {
          inPayload = &amp;<span style="color: #c792ea;">stats.InPayload</span>{
              <span style="color: #f78c6c;">Client</span>: <span style="color: #f78c6c;">true</span>,
          }
      }
      <span style="color: #89DDFF;">for</span> {
          <span style="color: #676E95;">//</span><span style="color: #676E95;">&#19968;&#30452;&#35835;&#21040;&#27969;&#20851;&#38381;</span>
          <span style="color: #89DDFF;">if</span> err = <span style="color: #82aaff;">recv</span>(p, dopts.codec, stream, dopts.dc, reply, math.MaxInt32, inPayload); err != <span style="color: #f78c6c;">nil</span> {
              <span style="color: #89DDFF;">if</span> err == io.EOF {
                  <span style="color: #89DDFF;">break</span>
              }
              <span style="color: #89DDFF;">return</span>
          }
      }
      <span style="color: #89DDFF;">if</span> inPayload != <span style="color: #f78c6c;">nil</span> &amp;&amp; err == io.EOF &amp;&amp; stream.<span style="color: #82aaff;">StatusCode</span>() == codes.OK {
          <span style="color: #676E95;">// </span><span style="color: #cc9393;">TODO</span><span style="color: #676E95;"> in the current implementation, inTrailer may be handled before inPayload in some cases.</span>
          <span style="color: #676E95;">// </span><span style="color: #676E95;">Fix the order if necessary.</span>
          stats.<span style="color: #82aaff;">HandleRPC</span>(ctx, inPayload)
      }
      c.trailerMD = stream.<span style="color: #82aaff;">Trailer</span>()
      <span style="color: #89DDFF;">return</span> <span style="color: #f78c6c;">nil</span>
}

<span style="color: #89DDFF;">func</span> <span style="color: #82aaff;">recv</span>(<span style="color: #ffcb6b;">p</span> *<span style="color: #c792ea;">parser</span>, <span style="color: #ffcb6b;">c</span> <span style="color: #c792ea;">Codec</span>, <span style="color: #ffcb6b;">s</span> *<span style="color: #c792ea;">transport.Stream</span>, <span style="color: #ffcb6b;">dc</span> <span style="color: #c792ea;">Decompressor</span>, <span style="color: #ffcb6b;">m</span> <span style="color: #89DDFF;">interface</span>{}, <span style="color: #ffcb6b;">maxMsgSize</span> <span style="color: #c792ea;">int</span>, <span style="color: #ffcb6b;">inPayload</span> *<span style="color: #c792ea;">stats.InPayload</span>) <span style="color: #c792ea;">error</span> {
      <span style="color: #676E95;">//</span><span style="color: #676E95;">&#25509;&#21463;&#25968;&#25454;</span>
      <span style="color: #ffcb6b;">pf</span>, <span style="color: #ffcb6b;">d</span>, <span style="color: #ffcb6b;">err</span> := p.<span style="color: #82aaff;">recvMsg</span>(maxMsgSize)
      <span style="color: #89DDFF;">if</span> err != <span style="color: #f78c6c;">nil</span> {
          <span style="color: #89DDFF;">return</span> err
      }
      <span style="color: #89DDFF;">if</span> inPayload != <span style="color: #f78c6c;">nil</span> {
          inPayload.WireLength = <span style="color: #82aaff;">len</span>(d)
      }
      <span style="color: #89DDFF;">if</span> <span style="color: #ffcb6b;">err</span> := <span style="color: #82aaff;">checkRecvPayload</span>(pf, s.<span style="color: #82aaff;">RecvCompress</span>(), dc); err != <span style="color: #f78c6c;">nil</span> {
          <span style="color: #89DDFF;">return</span> err
      }
      <span style="color: #89DDFF;">if</span> pf == compressionMade {
          <span style="color: #676E95;">//</span><span style="color: #676E95;">&#35299;&#21387;</span>
          d, err = dc.<span style="color: #82aaff;">Do</span>(bytes.<span style="color: #82aaff;">NewReader</span>(d))
          <span style="color: #89DDFF;">if</span> err != <span style="color: #f78c6c;">nil</span> {
              <span style="color: #89DDFF;">return</span> <span style="color: #82aaff;">Errorf</span>(codes.Internal, <span style="color: #c3e88d;">"grpc: failed to decompress the received message %v"</span>, err)
          }
      }
      <span style="color: #89DDFF;">if</span> <span style="color: #82aaff;">len</span>(d) &gt; maxMsgSize {
          <span style="color: #676E95;">// </span><span style="color: #cc9393;">TODO</span><span style="color: #676E95;">: Revisit the error code. Currently keep it consistent with java</span>
          <span style="color: #676E95;">// </span><span style="color: #676E95;">implementation.</span>
          <span style="color: #89DDFF;">return</span> <span style="color: #82aaff;">Errorf</span>(codes.Internal, <span style="color: #c3e88d;">"grpc: received a message of %d bytes exceeding %d limit"</span>, <span style="color: #82aaff;">len</span>(d), maxMsgSize)
      }
      <span style="color: #676E95;">//</span><span style="color: #676E95;">&#25968;&#25454;&#35299;&#30721;</span>
      <span style="color: #89DDFF;">if</span> <span style="color: #ffcb6b;">err</span> := c.<span style="color: #82aaff;">Unmarshal</span>(d, m); err != <span style="color: #f78c6c;">nil</span> {
          <span style="color: #89DDFF;">return</span> <span style="color: #82aaff;">Errorf</span>(codes.Internal, <span style="color: #c3e88d;">"grpc: failed to unmarshal the received message %v"</span>, err)
      }
      <span style="color: #89DDFF;">if</span> inPayload != <span style="color: #f78c6c;">nil</span> {
          inPayload.RecvTime = time.<span style="color: #82aaff;">Now</span>()
          inPayload.Payload = m
          <span style="color: #676E95;">// </span><span style="color: #cc9393;">TODO</span><span style="color: #676E95;"> truncate large payload.</span>
          inPayload.Data = d
          inPayload.Length = <span style="color: #82aaff;">len</span>(d)
      }
      <span style="color: #89DDFF;">return</span> <span style="color: #f78c6c;">nil</span>
}
</pre>
</div>
<p>
这里可以看到一个recvRespon可能会处理多个返回，但是确实在同一个for循环中处理的，有点奇怪。客户端代码大概就是这个流程。代码来说不算太复杂。（主要不钻进http2的实现,刚开始我就去看http2，一头雾水）
其中还有重要的地方就是负载均衡，通过它我们可以根据算法自动选择要连接的ip跟地址，还有验证的使用，放到下一篇吧
</p>
</div>
</div>
<div id="outline-container-org837623a" class="outline-2">
<h2 id="org837623a"><span class="section-number-2">4</span> 相关链接</h2>
<div class="outline-text-2" id="text-4">
<ol class="org-ol">
<li><a href="https://github.com/grpc/grpc/blob/master/doc/load-balancing.md">https://github.com/grpc/grpc/blob/master/doc/load-balancing.md</a> 负载均衡</li>
<li><a href="https://www.gitbook.com/book/ye11ow/http2-explained/details">https://www.gitbook.com/book/ye11ow/http2-explained/details</a> 介绍http2的书籍，写的非常好</li>
<li><a href="http://www.grpc.io/docs/guides/concepts.html#metadata">http://www.grpc.io/docs/guides/concepts.html#metadata</a> metadata介绍,在源码的Documentation目录有metadata的详细介绍</li>
</ol>
</div>
</div>
</div>
<div id="postamble" class="status">
<div id="gitalk" /> <script> var gitalk = new Gitalk({
  clientID: 'f30e66bb5ab9089aa742',
  clientSecret: '5d256d445447bd4db16540c2aab0e0884218ed12',
  repo: 'guidao.github.io',
  owner: 'guidao',
  admin: ['guidao'],
  id: location.pathname,      // Ensure uniqueness and length less than 50
  distractionFreeMode: false  // Facebook-like distraction free mode
})
gitalk.render('gitalk') </script>
</div>
</body>
</html>
